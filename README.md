## [1] 两数之和

算法启蒙，第一次了解 hash 表的强大之处

## [2] 两数相加

我的思路很简单，将链表转成数字再相加得到和，再把和转成链表，空间和时间复杂度都很感人。

官方解释就是链表不对称的补 0，将每个数相加余 10 得到需要存储的数字和 carry。

## [3] 无重复字符的最长子串

稀里糊涂做出来的，最后把我的代码给 chatgpt 优化就好看多了；整体思想也是利用了 **滑动窗口 + 链表**，也从 K 神哪里看到了动态规划解法，比较难，后面的题用到再深入。

## [4] 寻找两个正序数组的中位数

第一眼想到的是遍历数组然后存在二进制里面，再遍历二进制的一半得到中位数；不好写，然后就直接合并数组 sort，看题解还有两种解法，一个是二分法，一个根据中位数的定义划分得到中位数，后面两个时间复杂度是 log(m+n)。

## [1480] 一维数组的动态和

列表推导式一步到位

## [2288] 价格减免

python 解起来还是比较简单，思路和官方差不多，让 ai 优化代码变成一行，但是没跑出来

## [2713] 矩阵中严格递增的单元格数

这题真的难，考虑了很多最终还是去找题解了，只看到动态规划的解法

## [520] 检测大写字母

用 python 非常简单

## [503] 下一个更大元素 II

我的思路：双循环，官解：拉长列表 + 单调栈

## [2741] 特别的排列

利用 python 自带的工具进行排列组合进行暴力破解很快哈，但是时间效率不行，运行超时；先跳过这题，然后跟着灵神从基础刷着走

## [167] 两数之和 II - 输入有序数组

[听课] 因为数组有序，所以采用 **相向双指针** 的做法

时间复杂度：O(n)

空间复杂度：O(1)

## [15] 三数之和

[听课] 先排序，然后循环得第一个数，循环里面采用 **相向双指针** 取两个数判断是否满足条件

时间复杂度：O(n^2)

空间复杂度：O(1)

## [2824] 统计和小于目标的下标对数目

[课后题] 难度一般，使用相向指针，固定左指针，右指针 + 1，判断大于 target 就跳出。

时间复杂度：O(nlogn)

空间复杂度：O(logn)


## [16] 最接近的三数之和

[课后题] 比较难，使用相向指针，先定义一个变量存和，一个变量存距离，循环数组得 i，定义左指针 = i+1，定义右指针 = len-1，然后判断距离，距离变小就更新和。

时间复杂度：O(nlogn)

空间复杂度：O(logn)

## [18] 四数之和

[课后题] 比上题难，我的思路是在三数之和的基础上再套一层，固定两头变中间的指针。

时间复杂度：O(n^3logn)

空间复杂度：O(logn)